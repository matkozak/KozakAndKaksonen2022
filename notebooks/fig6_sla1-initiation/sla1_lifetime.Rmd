---
title: "Sla1 lifetime in Ede1 internal deletion mutants"
date: "Last compiled on `r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    code_download: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning=FALSE,
                      dpi = 96, fig.width = 4, fig.height = 3)
```

```{r libs}
library(tidyverse)
library(ggbeeswarm)
library(ggsignif)
library(broom)
library(rstatix)
library(knitr)
library(multcompView)
```

```{r load}
# Load data generated by cleanup notebook
rm(list = ls())
load('data/sla1_lifetime.RData')
```

```{r theme}
# Custom ggplot2 theme
# --------------------

# minimal theme with border
# based on theme_linedraw without the grid lines
# also trying to remove all backgrounds and margins
# the aim is to make it as easy as possible to edit in illustrator

theme_clean <- function(base_size = 11, base_family = "",
                        base_line_size = base_size / 22,
                        base_rect_size = base_size / 22) {
  theme_linedraw(
    base_size = base_size,
    base_family = base_family,
    base_line_size = base_line_size,
    base_rect_size = base_rect_size
  ) %+replace%
    theme(
      # no grid and no backgrounds if I can help it
      legend.background =  element_blank(),
      panel.background = element_blank(),
      panel.grid = element_blank(),
      plot.background = element_blank(),
      plot.margin = margin(0, 0, 0, 0),
      complete = TRUE
    )
}

# Set default theme
# -----------------
theme_set(theme_clean(base_size = 12, base_family = "Myriad Pro"))

# Create a ggsave wrapper
# -----------------------

# This way we can set a default size and device for all plots
my_ggsave <- function(filename, plot = last_plot(),
                      device = cairo_pdf, units = "mm",
                      width = 100, height = 80, ...){
  ggsave(filename = filename, plot = plot,
         device = device, units = units,
         height = height, width = width,  ...)
  }
```

```{r functions}
# couple of small functions for extracting comparisons
# into a format understandable by ggplot

#' Add letter group labels generated by Tukey's HSD
#'
#' This function performs ANOVA and Tukey's HSD,
#' extracts the letter labels and attaches them
#' to the original data.
#'
#' @param x: df or tibble, the data (long format!)
#' @param yvar: chr, name of the dependent variable
#' @param xvar: chr, name of the independent variable
#' @param alpha: dbl, confidence level passed on to Tukey's test
#'
add_tukey_labels <- function(x, yvar, xvar, alpha = 0.95){
  aov_form <- formula(paste(yvar, '~', xvar))
  anova <- aov(formula = aov_form, data = x)
  tukey <- TukeyHSD(anova, which = xvar, conf.level = alpha)
  # Extract labels and factor levels from Tukey post-hoc 
  x_labels <- as_tibble(
    multcompLetters4(anova, tukey)[[xvar]]$Letters,
    rownames = xvar
    )
  
  if (is.factor(x[[xvar]])) {
    x_labels[[xvar]] <- factor(
      x_labels[[xvar]], levels = levels(x[[xvar]])
    )
  }
  
  x_labels <- rename(x_labels, tukey_group = value)
  x <- left_join(x, x_labels, by = xvar)
  
  return(x)
  }


#' Extract comparisons from rstatix tidy tests
#' 
#' This function subsets the selected comparisons in a Tukey,
#' Dunn or similar test done by rstatix.
#' It converts groups to a list of vectors that can be passed to geom_signif
#'
#'
#' @param x: df or tibble, the comparison results
#' @param rows: integer vector, the rows with desired comparisons
extract_comparisons <- function(x, rows){
  x_subset <- x[rows,] %>%
    .[nrow(.):1,]
  
  x_comparisons <- x_subset %>%
    select(group1, group2) %>%
    t() %>%
    as.data.frame() %>%
    as.list
  x_annotations <- x_subset$p.adj.signif %>%
    as.vector()
  
  significance <- list(
    comparisons = x_comparisons,
    annotations = x_annotations
  )
  
  return(significance)
}
```

# {.tabset .tabset-pills}

## Experiment

### Rationale

The aim of the experiment is to determine patch initiation rates 
in Ede1 internal domain deletion mutants.
We looked at the patch density and lifetimes of late coat protein Sla1 
in Ede1 mutants lacking all or some of the central region.
This notebook is devoted to the Sla1 patch lifetime.

### Acquisition and replicates

All lifetime estimates come from movies 
acquired on the Olympus IX83 with a 150x/1.45 objective.
The illumination was CoolLED’s pE-300 lamp with a GFP filter cube. 
Camera was Hammamatsu's ImageEMX2 EMCCD.

The first dataset (#0 in this notebook) 
was acquired with 25% power and 200 ms exposure times. 
For the three subsequent datasets, 
  the lamp power was reduced to 15%, 
  and exposure was increased to 500 ms.
Despite this difference, the result from the first, exploratory dataset 
looks in line with the rest of the repeats,
so I decided to include it in the analysis.

### Processing and data extraction

All images were background subtracted 
using ImageJ rolling ball algorithm with 80 px radius, 
and normalized to correct for photobleaching.
Individual cells were cropped out 
and median-filtered image (6px disk brush) was subtracted. 
ParticleTracker from the MOSAIC Suite was used to track the spots.
Individual tracks were manually selected based on the quality of the tracking.

Another notebook was used to gather all output into tidy data frames
with no further modifications.

### List of strains used

```{r strains}
kable(strains)
```

## Per-dataset summary

Basic summary of each dataset: exact sample sizes, mean, sd, se, median, MAD.

```{r stats}
sla1_lifetime_stats <- sla1_lifetime %>%
  group_by(ede1, dataset) %>%
  summarise(n = n(),
            across(lifetime,
                   list(mean = mean, sd = sd, 
                        se = ~ sd(.x) / sqrt(n()),
                        median = median, mad = mad)),
            .groups = 'drop')

sla1_lifetime_stats %>% kable()
```

## Plots {.tabset}

```{r lifetime.scatter}
plot_blank <- ggplot(sla1_lifetime_stats,
                     aes(x = ede1, y = lifetime_mean)) +
                         #shape = dataset, fill = dataset))+
  labs(title = NULL, x = 'Ede1', y = "Sla1 lifetime (s)") +
  scale_y_continuous(breaks = scales::breaks_extended(6))+
  scale_shape_manual(values = c(21:25)) +
  scale_color_brewer(palette = 'Set2') +
  scale_fill_brewer(palette = 'Set2')

plot_scatter <- plot_blank +
  geom_quasirandom(inherit.aes = F, data = sla1_lifetime,
                   aes(x = ede1, y = lifetime,
                       shape = dataset,# colour = dataset
                       ),
                   colour = 'grey75',# shape = 1,
                   show.legend = F, size = 0.8
                   )

plot_violin <- plot_blank + 
  geom_violin(inherit.aes = F,
              data = sla1_lifetime, aes(x = ede1, y = lifetime),
              colour = 'grey75', fill = 'transparent'
              )
```

### SuperPlots

Large, coloured points represent mean values 
from each independent experiment.
The center line and range represent the mean +/- SD, 
calculated based on the experimental averages.

Beeswarm points represent all underlying observations, 
shaped according to the dataset.

```{r}
plot_super <- plot_scatter +
  geom_quasirandom(aes(shape = dataset, fill = dataset),
                   show.legend = F,
                   width = 0.3, size = 2)+
  stat_summary(fun = mean, geom = 'crossbar',
               width = 0.5, fatten = 1)+
  stat_summary(fun.data = 'mean_sdl',
               fun.args = list(mult = 1), 
               geom = 'errorbar', width = 0.2)
  
print(plot_super)
my_ggsave('figures/lifetime_super.pdf')
```

Violin instead of beeswarm to summarize all observations:

```{r}
plot_super_violin <- plot_violin +
  geom_quasirandom(aes(shape = dataset, fill = dataset),
                   show.legend = F,
                   width = 0.3, size = 2)+
  stat_summary(fun = mean, geom = 'crossbar',
               width = 0.5, fatten = 1)+
  stat_summary(fun.data = 'mean_sdl',
               fun.args = list(mult = 1),
               geom = 'errorbar', width = 0.2)

print(plot_super_violin)
my_ggsave('figures/lifetime_super_violin.pdf')
```

### With significance

Let's add significance stars based on Tukey's test.

```{r}
tukey <- tukey_hsd(sla1_lifetime_stats, lifetime_mean ~ ede1,
                   ordered = TRUE)

significance <- extract_comparisons(tukey, c(1:4, 10))

plot_super_signif <- plot_super +
  geom_signif(comparisons = significance$comparisons,
              annotations = significance$annotations,
              step_increase = 0.03,
              tip_length = 0.01, vjust = 0.8,
              margin_top = -0.1)
print(plot_super_signif)
my_ggsave('figures/lifetime_super_signif.pdf')
```

Like with density, this view is getting complicated
even though it's only half of the comparisons.

We can simplify it down to binary comparisons at a given α level (here, α = 0.95).
We can reject the null of group mean equality at this level
for groups which do not share any letters between them.

```{r}
sla1_lifetime_stats <- sla1_lifetime_stats %>%
  add_tukey_labels('lifetime_mean', 'ede1')
```

```{r}
plot_super_letters <- plot_super +
  geom_text(data = sla1_lifetime_stats,
            aes(label = tukey_group), y = Inf, vjust = 1.2)

print(plot_super_letters)
my_ggsave('figures/lifetime_super_letters.pdf')
```

## Hypothesis tests {.tabset}

### Assumptions

ANOVA and similar parametric tests 
assume that the errors are normally distributed,
with homogeneous variances,
and that the samples are independent.
We will test the null hypothesis that mean Sla1 lifetime is the same
across different Ede1 strains.

We will use repeat-level data for the tests
to account for experimental variability.
Also, even if the populations are skewed (as it seems from the plots),
the sample means should still be normally distributed
(according to the Central Limit Theorem). 

#### Normality

From the plots it looks like the underlying data
is not perfectly normal with some skew.
We can check the normality of residuals used in the model later, but it might
still be interesting to know how normal the underlying data is overall.

If we do a formal test (Shapiro-Wilkes):

```{r}
sla1_lifetime %>%
  group_by(ede1) %>%
  summarise(n = n(),
            p.value = tidy(shapiro.test(lifetime))$p.value, 
            .groups = 'drop') %>%
  kable()
```

Shapiro-Wilkes rejects the normality of the data in each group.
That is about expected with a large sample size, but it
probably also reflects an actual skew in lifetimes.

Q-Q plots:

```{r fig.height=6, fig.width=8}
sla1_lifetime %>%
  ggplot(aes(sample = lifetime))+
  facet_wrap('ede1', scales = 'free')+          
  stat_qq(shape = 1)+
  stat_qq_line()
```

All datasets do indeed look heavy-tailed. Histograms:

```{r fig.height=6, fig.width=8}
sla1_lifetime %>%
  ggplot(aes(x = lifetime))+
  facet_wrap('ede1', scales = 'free')+          
  geom_histogram()
```

#### Homoscedasticity

4 points per group is probably enough to assess
whether the variance is similar in the repeat-level data.
Levene's test:

```{r}
sla1_lifetime_stats %>%
  levene_test(lifetime_mean ~ ede1) %>%
  kable()
```

Levene's cannot reject the null here (variance does not differ between groups).

### One-way ANOVA

```{r}
anova <- aov(lifetime_mean ~ ede1, data = sla1_lifetime_stats)
tidy(anova) %>% kable()
```

One-way ANOVA rejects the null hypothesis with $p = 2.8\times10^{-6}$.

#### Diagnostic plots

```{r}
plot(anova)
```

Again, the variance looks homogeneous enough. 
There is a departure from normality, although
I am not sure how concerning it really is.

### Post-hoc test (Tukey)

```{r}
tukey %>%
  kable()
```

All mutants are significantly different than wild-type,
but not necessarily between themselves. 
Most notably, we do not have enough power to say
if ∆CC is different from ∆PQ, ∆PQCC or ede1∆.
At the same time, ∆PQ difference from ∆PQCC and ede1∆ reaches
the significance threshold.

## Overall summary

Summary statistics for all experiments, derived from *mean values*
of N independent repeats.

### Final estimates

Final estimates with lower / upper 95% confidence intervals and a comparison
to wild type (in %). `half_ci` is just the error for writing CI ranges
in the format mean +/- error.

```{r}
wt_mean <- sla1_lifetime_stats %>%
  filter(ede1 == 'wt') %>%
  pull(lifetime_mean) %>%
  mean()

lifetime_ci <- sla1_lifetime_stats %>%
  group_by(ede1)%>%
  summarise(mean_cl_normal(lifetime_mean)) %>%
  rename(mean = y, lower = ymin, upper = ymax) %>%
  mutate(proc_wt = round(100 * mean / wt_mean),
         half_ci = (upper - lower) / 2) 

kable(lifetime_ci, digits = 3)
```

### Conclusions

1. All mutations cause a significant reduction in Sla1 patch lifetime from wild type
2. Ede1∆PQCC is indistinguishable from full Ede1 deletion, 
  causes ~30% reduction in lifetime
3. Individual PQ / CC deletions have intermediate defects

### More statistics

```{r}
sla1_lifetime_stats %>%
  group_by(ede1)%>%
  summarise(N = n(),
            across(lifetime_mean,
                   list(mean = mean, sd = sd,
                        se = ~ sd(.x) / sqrt(n()),
                        median = median, mad = mad),
                       .names = '{.fn}'),
            .groups = 'drop') %>%
  kable(digits = 3)
```

### More statistics (observation-level)

It might be useful to also look at observation-level summary.
The experimental means can be used to determine
true population mean (because of the CLT),
but if the population is  really skewed,
median and quartiles are particularly useful information
which cannot be accurately assessed from only 4 points.

```{r}
sla1_lifetime %>%
  group_by(ede1)%>%
  summarise(n = n(),
            across(lifetime,
                   list(mean = mean, sd = sd,
                        se = ~ sd(.x) / sqrt(n()),
                        median = median, mad = mad
                        #, quant = ~quantile(.x, c(0.25, 0.5, 0.75))
                        ),
                       .names = '{.fn}'),
            pivot_wider(enframe(quantile(lifetime, c(0.25, 0.75)))),
            .groups = 'drop') %>%
  
  kable(digits = 3)
```

## Source data

### .csv

```{r echo=FALSE}
xfun::embed_file('data/sla1_lifetime.csv')
```

### .RData

```{r echo=FALSE}
xfun::embed_file('data/sla1_lifetime.RData')
```

## Session info

```{r session, message=TRUE}
sessionInfo()
```